# redo requests in the output dir all fall back to $OUT/default.do, which
# simply sets $SRCDIR and then runs this file.
#
# Our job is then to delegate the work the right .do file inside $SRCDIR,
# if any.
redo-use-whichdo(){
    redo-whichdo "$1" | {
        ifcreate=
        while read dopath; do
            if [ ! -e "$dopath" ]; then
                ifcreate="$ifcreate $dopath"
            else
                redo-ifcreate $ifcreate
                redo-ifchange "$dopath"
                echo "$dopath"
            fi
        done
    }
}
redo-run(){
    dofile=$1; shift
    x1=$1; x2=$2; x3=$3
    # This is slightly faster than forking $(dirname) and $(basename),
    # plus doesn't try to do any magic like using '.' for an empty
    # dir field.
    dofile=${dopath##*/}
    dodir=${dopath%$dofile}

    # .do files always expect to be run with $PWD set to their own
    # directory.
    cd "$dodir"

    # Calculate the $1 path relative to the new $dodir.
    # Note: if $dodir is nonempty, it will have a trailing slash,
    # because of the way it's constructed.
    #
    # What we want is to run $dofile from $dodir in the *source*
    # directory.  We then lie a bit in $1/$2: we provide a relative
    # path to where we expect the *source* file to reside, even though
    # $3 will actually end up putting the output at the same relative
    # path inside $OUT.
    set -- "${x1#$dodir}" "${x2#$dodir}" "$x3"
    . "./$dofile"
}

redo-basename(){
    x1=$1; dofile=$2
    # Calculate the $2 relative path.
    # We can't start with $2 here, because we were called from
    # default.do and redo-whichdo might have afound a default.o.do,
    # for example.  We have to strip the extension from $1 ourselves.
    dofile=${dofile##*/}
    ext=${dofile##*default}
    if [ "$ext" != "$dofile"]; then
      ext=${ext%.do}
      echo "${x1%ext}"
    else
      echo "$x1"
    fi
}

OUT=$PWD
cd "$SRCDIR"
whichdo=$(redo-use-whichdo "$1")
redo-run "$whichdo" "$1" "$(redo-basename "$1" "$whichdo")" "$OUT/$3"
